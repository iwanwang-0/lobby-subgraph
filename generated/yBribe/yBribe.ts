// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Blacklisted extends ethereum.Event {
  get params(): Blacklisted__Params {
    return new Blacklisted__Params(this);
  }
}

export class Blacklisted__Params {
  _event: Blacklisted;

  constructor(event: Blacklisted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ChangeOwner extends ethereum.Event {
  get params(): ChangeOwner__Params {
    return new ChangeOwner__Params(this);
  }
}

export class ChangeOwner__Params {
  _event: ChangeOwner;

  constructor(event: ChangeOwner) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ClearRewardRecipient extends ethereum.Event {
  get params(): ClearRewardRecipient__Params {
    return new ClearRewardRecipient__Params(this);
  }
}

export class ClearRewardRecipient__Params {
  _event: ClearRewardRecipient;

  constructor(event: ClearRewardRecipient) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class FeeUpdated extends ethereum.Event {
  get params(): FeeUpdated__Params {
    return new FeeUpdated__Params(this);
  }
}

export class FeeUpdated__Params {
  _event: FeeUpdated;

  constructor(event: FeeUpdated) {
    this._event = event;
  }

  get fee(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class NewTokenReward extends ethereum.Event {
  get params(): NewTokenReward__Params {
    return new NewTokenReward__Params(this);
  }
}

export class NewTokenReward__Params {
  _event: NewTokenReward;

  constructor(event: NewTokenReward) {
    this._event = event;
  }

  get gauge(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reward_token(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PeriodUpdated extends ethereum.Event {
  get params(): PeriodUpdated__Params {
    return new PeriodUpdated__Params(this);
  }
}

export class PeriodUpdated__Params {
  _event: PeriodUpdated;

  constructor(event: PeriodUpdated) {
    this._event = event;
  }

  get gauge(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get period(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get bias(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get blacklisted_bias(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class RemovedFromBlacklist extends ethereum.Event {
  get params(): RemovedFromBlacklist__Params {
    return new RemovedFromBlacklist__Params(this);
  }
}

export class RemovedFromBlacklist__Params {
  _event: RemovedFromBlacklist;

  constructor(event: RemovedFromBlacklist) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RewardAdded extends ethereum.Event {
  get params(): RewardAdded__Params {
    return new RewardAdded__Params(this);
  }
}

export class RewardAdded__Params {
  _event: RewardAdded;

  constructor(event: RewardAdded) {
    this._event = event;
  }

  get briber(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get gauge(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get reward_token(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get fee(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class RewardClaimed extends ethereum.Event {
  get params(): RewardClaimed__Params {
    return new RewardClaimed__Params(this);
  }
}

export class RewardClaimed__Params {
  _event: RewardClaimed;

  constructor(event: RewardClaimed) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get gauge(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get reward_token(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class SetRewardRecipient extends ethereum.Event {
  get params(): SetRewardRecipient__Params {
    return new SetRewardRecipient__Params(this);
  }
}

export class SetRewardRecipient__Params {
  _event: SetRewardRecipient;

  constructor(event: SetRewardRecipient) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class yBribe extends ethereum.SmartContract {
  static bind(address: Address): yBribe {
    return new yBribe("yBribe", address);
  }

  _gauges_per_reward(param0: Address, param1: BigInt): Address {
    let result = super.call(
      "_gauges_per_reward",
      "_gauges_per_reward(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toAddress();
  }

  try__gauges_per_reward(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "_gauges_per_reward",
      "_gauges_per_reward(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  _rewards_in_gauge(param0: Address, param1: Address): boolean {
    let result = super.call(
      "_rewards_in_gauge",
      "_rewards_in_gauge(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try__rewards_in_gauge(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "_rewards_in_gauge",
      "_rewards_in_gauge(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  _rewards_per_gauge(param0: Address, param1: BigInt): Address {
    let result = super.call(
      "_rewards_per_gauge",
      "_rewards_per_gauge(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toAddress();
  }

  try__rewards_per_gauge(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "_rewards_per_gauge",
      "_rewards_per_gauge(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  active_period(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "active_period",
      "active_period(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_active_period(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "active_period",
      "active_period(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  add_reward_amount(
    gauge: Address,
    reward_token: Address,
    amount: BigInt
  ): boolean {
    let result = super.call(
      "add_reward_amount",
      "add_reward_amount(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_add_reward_amount(
    gauge: Address,
    reward_token: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "add_reward_amount",
      "add_reward_amount(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  claim_reward(gauge: Address, reward_token: Address): BigInt {
    let result = super.call(
      "claim_reward",
      "claim_reward(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );

    return result[0].toBigInt();
  }

  try_claim_reward(
    gauge: Address,
    reward_token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "claim_reward",
      "claim_reward(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claim_reward_for(
    user: Address,
    gauge: Address,
    reward_token: Address
  ): BigInt {
    let result = super.call(
      "claim_reward_for",
      "claim_reward_for(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );

    return result[0].toBigInt();
  }

  try_claim_reward_for(
    user: Address,
    gauge: Address,
    reward_token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "claim_reward_for",
      "claim_reward_for(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claim_reward_for_many(
    _users: Array<Address>,
    _gauges: Array<Address>,
    _reward_tokens: Array<Address>
  ): Array<BigInt> {
    let result = super.call(
      "claim_reward_for_many",
      "claim_reward_for_many(address[],address[],address[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(_users),
        ethereum.Value.fromAddressArray(_gauges),
        ethereum.Value.fromAddressArray(_reward_tokens)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_claim_reward_for_many(
    _users: Array<Address>,
    _gauges: Array<Address>,
    _reward_tokens: Array<Address>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "claim_reward_for_many",
      "claim_reward_for_many(address[],address[],address[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(_users),
        ethereum.Value.fromAddressArray(_gauges),
        ethereum.Value.fromAddressArray(_reward_tokens)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  claimable(user: Address, gauge: Address, reward_token: Address): BigInt {
    let result = super.call(
      "claimable",
      "claimable(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );

    return result[0].toBigInt();
  }

  try_claimable(
    user: Address,
    gauge: Address,
    reward_token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "claimable",
      "claimable(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddress(gauge),
        ethereum.Value.fromAddress(reward_token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claims_per_gauge(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "claims_per_gauge",
      "claims_per_gauge(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_claims_per_gauge(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "claims_per_gauge",
      "claims_per_gauge(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  current_period(): BigInt {
    let result = super.call("current_period", "current_period():(uint256)", []);

    return result[0].toBigInt();
  }

  try_current_period(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "current_period",
      "current_period():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fee_percent(): BigInt {
    let result = super.call("fee_percent", "fee_percent():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fee_percent(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("fee_percent", "fee_percent():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fee_recipient(): Address {
    let result = super.call("fee_recipient", "fee_recipient():(address)", []);

    return result[0].toAddress();
  }

  try_fee_recipient(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "fee_recipient",
      "fee_recipient():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  gauges_per_reward(reward: Address): Array<Address> {
    let result = super.call(
      "gauges_per_reward",
      "gauges_per_reward(address):(address[])",
      [ethereum.Value.fromAddress(reward)]
    );

    return result[0].toAddressArray();
  }

  try_gauges_per_reward(reward: Address): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "gauges_per_reward",
      "gauges_per_reward(address):(address[])",
      [ethereum.Value.fromAddress(reward)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  get_blacklist(): Array<Address> {
    let result = super.call("get_blacklist", "get_blacklist():(address[])", []);

    return result[0].toAddressArray();
  }

  try_get_blacklist(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "get_blacklist",
      "get_blacklist():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  get_blacklisted_bias(gauge: Address): BigInt {
    let result = super.call(
      "get_blacklisted_bias",
      "get_blacklisted_bias(address):(uint256)",
      [ethereum.Value.fromAddress(gauge)]
    );

    return result[0].toBigInt();
  }

  try_get_blacklisted_bias(gauge: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "get_blacklisted_bias",
      "get_blacklisted_bias(address):(uint256)",
      [ethereum.Value.fromAddress(gauge)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  is_blacklisted(address_to_check: Address): boolean {
    let result = super.call(
      "is_blacklisted",
      "is_blacklisted(address):(bool)",
      [ethereum.Value.fromAddress(address_to_check)]
    );

    return result[0].toBoolean();
  }

  try_is_blacklisted(address_to_check: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "is_blacklisted",
      "is_blacklisted(address):(bool)",
      [ethereum.Value.fromAddress(address_to_check)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  last_user_claim(param0: Address, param1: Address, param2: Address): BigInt {
    let result = super.call(
      "last_user_claim",
      "last_user_claim(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromAddress(param2)
      ]
    );

    return result[0].toBigInt();
  }

  try_last_user_claim(
    param0: Address,
    param1: Address,
    param2: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "last_user_claim",
      "last_user_claim(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromAddress(param2)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  next_claim_time(param0: Address): BigInt {
    let result = super.call(
      "next_claim_time",
      "next_claim_time(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_next_claim_time(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "next_claim_time",
      "next_claim_time(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  pending_owner(): Address {
    let result = super.call("pending_owner", "pending_owner():(address)", []);

    return result[0].toAddress();
  }

  try_pending_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "pending_owner",
      "pending_owner():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reward_per_gauge(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "reward_per_gauge",
      "reward_per_gauge(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_reward_per_gauge(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reward_per_gauge",
      "reward_per_gauge(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reward_per_token(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "reward_per_token",
      "reward_per_token(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_reward_per_token(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reward_per_token",
      "reward_per_token(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reward_recipient(param0: Address): Address {
    let result = super.call(
      "reward_recipient",
      "reward_recipient(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_reward_recipient(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "reward_recipient",
      "reward_recipient(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewards_per_gauge(gauge: Address): Array<Address> {
    let result = super.call(
      "rewards_per_gauge",
      "rewards_per_gauge(address):(address[])",
      [ethereum.Value.fromAddress(gauge)]
    );

    return result[0].toAddressArray();
  }

  try_rewards_per_gauge(gauge: Address): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "rewards_per_gauge",
      "rewards_per_gauge(address):(address[])",
      [ethereum.Value.fromAddress(gauge)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }
}

export class Accept_ownerCall extends ethereum.Call {
  get inputs(): Accept_ownerCall__Inputs {
    return new Accept_ownerCall__Inputs(this);
  }

  get outputs(): Accept_ownerCall__Outputs {
    return new Accept_ownerCall__Outputs(this);
  }
}

export class Accept_ownerCall__Inputs {
  _call: Accept_ownerCall;

  constructor(call: Accept_ownerCall) {
    this._call = call;
  }
}

export class Accept_ownerCall__Outputs {
  _call: Accept_ownerCall;

  constructor(call: Accept_ownerCall) {
    this._call = call;
  }
}

export class Add_reward_amountCall extends ethereum.Call {
  get inputs(): Add_reward_amountCall__Inputs {
    return new Add_reward_amountCall__Inputs(this);
  }

  get outputs(): Add_reward_amountCall__Outputs {
    return new Add_reward_amountCall__Outputs(this);
  }
}

export class Add_reward_amountCall__Inputs {
  _call: Add_reward_amountCall;

  constructor(call: Add_reward_amountCall) {
    this._call = call;
  }

  get gauge(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get reward_token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class Add_reward_amountCall__Outputs {
  _call: Add_reward_amountCall;

  constructor(call: Add_reward_amountCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class Add_to_blacklistCall extends ethereum.Call {
  get inputs(): Add_to_blacklistCall__Inputs {
    return new Add_to_blacklistCall__Inputs(this);
  }

  get outputs(): Add_to_blacklistCall__Outputs {
    return new Add_to_blacklistCall__Outputs(this);
  }
}

export class Add_to_blacklistCall__Inputs {
  _call: Add_to_blacklistCall;

  constructor(call: Add_to_blacklistCall) {
    this._call = call;
  }

  get _user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class Add_to_blacklistCall__Outputs {
  _call: Add_to_blacklistCall;

  constructor(call: Add_to_blacklistCall) {
    this._call = call;
  }
}

export class Claim_rewardCall extends ethereum.Call {
  get inputs(): Claim_rewardCall__Inputs {
    return new Claim_rewardCall__Inputs(this);
  }

  get outputs(): Claim_rewardCall__Outputs {
    return new Claim_rewardCall__Outputs(this);
  }
}

export class Claim_rewardCall__Inputs {
  _call: Claim_rewardCall;

  constructor(call: Claim_rewardCall) {
    this._call = call;
  }

  get gauge(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get reward_token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class Claim_rewardCall__Outputs {
  _call: Claim_rewardCall;

  constructor(call: Claim_rewardCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class Claim_reward_forCall extends ethereum.Call {
  get inputs(): Claim_reward_forCall__Inputs {
    return new Claim_reward_forCall__Inputs(this);
  }

  get outputs(): Claim_reward_forCall__Outputs {
    return new Claim_reward_forCall__Outputs(this);
  }
}

export class Claim_reward_forCall__Inputs {
  _call: Claim_reward_forCall;

  constructor(call: Claim_reward_forCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get gauge(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get reward_token(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class Claim_reward_forCall__Outputs {
  _call: Claim_reward_forCall;

  constructor(call: Claim_reward_forCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class Claim_reward_for_manyCall extends ethereum.Call {
  get inputs(): Claim_reward_for_manyCall__Inputs {
    return new Claim_reward_for_manyCall__Inputs(this);
  }

  get outputs(): Claim_reward_for_manyCall__Outputs {
    return new Claim_reward_for_manyCall__Outputs(this);
  }
}

export class Claim_reward_for_manyCall__Inputs {
  _call: Claim_reward_for_manyCall;

  constructor(call: Claim_reward_for_manyCall) {
    this._call = call;
  }

  get _users(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get _gauges(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get _reward_tokens(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }
}

export class Claim_reward_for_manyCall__Outputs {
  _call: Claim_reward_for_manyCall;

  constructor(call: Claim_reward_for_manyCall) {
    this._call = call;
  }

  get amounts(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class Clear_recipientCall extends ethereum.Call {
  get inputs(): Clear_recipientCall__Inputs {
    return new Clear_recipientCall__Inputs(this);
  }

  get outputs(): Clear_recipientCall__Outputs {
    return new Clear_recipientCall__Outputs(this);
  }
}

export class Clear_recipientCall__Inputs {
  _call: Clear_recipientCall;

  constructor(call: Clear_recipientCall) {
    this._call = call;
  }
}

export class Clear_recipientCall__Outputs {
  _call: Clear_recipientCall;

  constructor(call: Clear_recipientCall) {
    this._call = call;
  }
}

export class Remove_from_blacklistCall extends ethereum.Call {
  get inputs(): Remove_from_blacklistCall__Inputs {
    return new Remove_from_blacklistCall__Inputs(this);
  }

  get outputs(): Remove_from_blacklistCall__Outputs {
    return new Remove_from_blacklistCall__Outputs(this);
  }
}

export class Remove_from_blacklistCall__Inputs {
  _call: Remove_from_blacklistCall;

  constructor(call: Remove_from_blacklistCall) {
    this._call = call;
  }

  get _user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class Remove_from_blacklistCall__Outputs {
  _call: Remove_from_blacklistCall;

  constructor(call: Remove_from_blacklistCall) {
    this._call = call;
  }
}

export class Set_fee_percentCall extends ethereum.Call {
  get inputs(): Set_fee_percentCall__Inputs {
    return new Set_fee_percentCall__Inputs(this);
  }

  get outputs(): Set_fee_percentCall__Outputs {
    return new Set_fee_percentCall__Outputs(this);
  }
}

export class Set_fee_percentCall__Inputs {
  _call: Set_fee_percentCall;

  constructor(call: Set_fee_percentCall) {
    this._call = call;
  }

  get _percent(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class Set_fee_percentCall__Outputs {
  _call: Set_fee_percentCall;

  constructor(call: Set_fee_percentCall) {
    this._call = call;
  }
}

export class Set_fee_recipientCall extends ethereum.Call {
  get inputs(): Set_fee_recipientCall__Inputs {
    return new Set_fee_recipientCall__Inputs(this);
  }

  get outputs(): Set_fee_recipientCall__Outputs {
    return new Set_fee_recipientCall__Outputs(this);
  }
}

export class Set_fee_recipientCall__Inputs {
  _call: Set_fee_recipientCall;

  constructor(call: Set_fee_recipientCall) {
    this._call = call;
  }

  get _recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class Set_fee_recipientCall__Outputs {
  _call: Set_fee_recipientCall;

  constructor(call: Set_fee_recipientCall) {
    this._call = call;
  }
}

export class Set_ownerCall extends ethereum.Call {
  get inputs(): Set_ownerCall__Inputs {
    return new Set_ownerCall__Inputs(this);
  }

  get outputs(): Set_ownerCall__Outputs {
    return new Set_ownerCall__Outputs(this);
  }
}

export class Set_ownerCall__Inputs {
  _call: Set_ownerCall;

  constructor(call: Set_ownerCall) {
    this._call = call;
  }

  get _new_owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class Set_ownerCall__Outputs {
  _call: Set_ownerCall;

  constructor(call: Set_ownerCall) {
    this._call = call;
  }
}

export class Set_recipientCall extends ethereum.Call {
  get inputs(): Set_recipientCall__Inputs {
    return new Set_recipientCall__Inputs(this);
  }

  get outputs(): Set_recipientCall__Outputs {
    return new Set_recipientCall__Outputs(this);
  }
}

export class Set_recipientCall__Inputs {
  _call: Set_recipientCall;

  constructor(call: Set_recipientCall) {
    this._call = call;
  }

  get _recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class Set_recipientCall__Outputs {
  _call: Set_recipientCall;

  constructor(call: Set_recipientCall) {
    this._call = call;
  }
}
